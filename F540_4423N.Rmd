---
title: "F540 Project 4423N"
output: html_document
date: "2024-03-25"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r message = FALSE, include = FALSE}
library(tidyverse)
library(RSQLite)
library(dbplyr)
library(tibbletime)
library(xts)
library(timetk)
```

```{r}
# should be able to do a range of market-neutral, dollar-neutral etc. strategies using parallel approach to OPR

# create portfolio specification
init.portf <- portfolio.spec(assets = funds)
init.portf <- add.objective(portfolio = init.portf, type = 'return', name = 'mean')
init.portf <- add.objective(portfolio = init.portf, type = 'risk', name = 'StdDev')
init.portf <- add.constraint(portfolio = init.portf, type = 'long_only')
init.portf <- add.constraint(portfolio = init.portf, type = 'transaction_cost', ptc = 0.005)

# optimisation runs in parallel with no momentFUN argument

# THIS WORKS! Takes about 10 minutes to run. 
# Can apply exactly this code to other strategies
cl <- makeCluster(detectCores() - 2)
registerDoParallel(cl)

optimize.portfolio.rebalancing(
    R, portfolio = init.portf, 
    optimize_method = 'DEoptim',
    DEoptim.control = list(parallel = TRUE,
                           parallelType = 1,
                           packages = "iterators"),
    trace = TRUE, 
    rebalance_on = 'months', 
    training_period = 120
    )

stopCluster(cl)
```

```{r ppp}
# importing Fama-French 5 factor data for evaluation
F540_project_data <- dbConnect(
    SQLite(),
    'data/F540-project-data', 
    extended_types = TRUE
    )

ff5_monthly <- tbl(F540_project_data, 'ff5_monthly') %>% collect()

dbDisconnect(F540_project_data)

ppp_data <- crsp_monthly %>% 
    filter(permno %in% selected_permnos) %>% 
    dplyr::select(permno, date, ret_excess, mktcap, mkt_excess)

# create one-month lagged market cap and join to data
mktcap_lag <- crsp_monthly %>% 
    mutate(date = date %m+% months(1)) %>% 
    dplyr::select(permno, date, mktcap_lag = mktcap)

ppp_data <- ppp_data %>% 
    left_join(mktcap_lag, join_by(permno, date)) %>% 
    na.omit() # drop first month for which there is no lag


# creating momentum_lag and size_lag variables
ppp_monthly_lags <- ppp_data %>% 
    transmute(permno, 
              date_13 = date %m+% months(13),
              mktcap
              )

ppp_data <- ppp_data %>% 
    inner_join(ppp_monthly_lags, 
               join_by(permno, date == date_13), 
               suffix = c('', '_13')
               )

ppp_data <- ppp_data %>% 
    mutate(
        momentum_lag = mktcap_lag / mktcap_13,
        size_lag = log(mktcap_lag)
    ) %>% 
    drop_na(contains('lag'))

# cross-sectional standardisation (scaling each feature at each time period)
ppp_data <- ppp_data %>%
    group_by(date) %>%
    mutate(
        n = n(), # number of assets
        relative_mktcap = mktcap_lag / sum(mktcap_lag), # use to keep track of value-weighted benchmark portfolio
        across(contains("lag"), ~ (. - mean(.)) / sd(.))
    ) %>% # standardisation
    ungroup() %>%
    dplyr::select(-mktcap_lag)

# Computing Portfolio Weights #

# define number of parameters using 'lag' in name
n_parameters <- sum(str_detect(
    colnames(ppp_data), "lag")
    )

# computes optimal weights for a given theta 
compute_portfolio_weights <- function(theta, data,
                                      value_weighting = FALSE,
                                      allow_short_selling = TRUE){
    data %>% 
        group_by(date) %>% 
        bind_cols(
            characteristic_tilt = data %>% 
                transmute(across(contains('lag'), ~ . / n)) %>% 
                as.matrix %*% theta %>% as.numeric()
        ) %>% 
        mutate(
            # Definition of benchmark weight
            weight_benchmark = case_when(
                value_weighting == TRUE ~ relative_mktcap,
                value_weighting == FALSE ~ 1 / n
            ),
            # Parametric portfolio weights
            weight_tilt = weight_benchmark + characteristic_tilt,
            # Short-sell constraint
            weight_tilt = case_when(
                allow_short_selling == TRUE ~ weight_tilt,
                allow_short_selling == FALSE ~ pmax(0, weight_tilt)
            ),
            # Weights sum to 1
            weight_tilt = weight_tilt / sum(weight_tilt)
        ) %>% 
        ungroup()
}


# Portfolio Performance Analysis #

# To analyse the performance we focus on the utility of a hypothetical investor with a power/CRRA utility function
power_utility <- function(r, gamma = 5){
    (1 + r)^(1 - gamma) / (1 - gamma)
}

evaluate_portfolio <- function(weights, 
                               capm_evaluation = TRUE,
                               full_evaluation = TRUE, 
                               length_year = 12){
    evaluation <- weights %>% 
        group_by(date) %>% 
        summarise(
            tilt = weighted.mean(ret_excess, weight_tilt), 
            benchmark = weighted.mean(ret_excess, weight_benchmark)
        ) %>% 
        pivot_longer(-date, 
                     values_to = 'portfolio_return', 
                     names_to = 'model'
        )
    
    evaluation_stats <- evaluation %>% 
        group_by(model) %>% 
        left_join(ff5_monthly, 
                  join_by(date == month)) %>% 
        summarise(tibble(
            "Expected utility" = mean(power_utility(portfolio_return)),
            "Average return" = 100 * mean(length_year * portfolio_return),
            "SD return" = 100 * sqrt(length_year) * sd(portfolio_return),
            "Sharpe ratio" = sqrt(length_year) * mean(portfolio_return) / sd(portfolio_return),
        )) %>% 
        mutate(model = str_remove(model, 'return_'))
    
    if (capm_evaluation) {
        evaluation_capm <- evaluation %>% 
            left_join(ff5_monthly, 
                      join_by(date == month)) %>% 
            group_by(model) %>% 
            summarise(
                'CAPM alpha' = coefficients(lm(portfolio_return ~ mkt_excess))[1],
                'Market Beta' = coefficients(lm(portfolio_return ~ mkt_excess))[2]
            )
        
        evaluation_stats <- evaluation_stats %>% 
            left_join(evaluation_capm, join_by(model))
    }
    
    if (full_evaluation) {
        evaluation_weights <- weights %>% 
            dplyr::select(date, contains('weight')) %>% 
            pivot_longer(-date, values_to = 'weight', names_to = 'model') %>% 
            group_by(model, date) %>% 
            mutate(
                'Absolute weight' = abs(weight),
                'Max. weight' = max(weight), 
                'Min. weight' = min(weight), 
                'Avg. sum of negative weights' = -sum(weight[weight < 0]),
                'Avg. fraction of negative weights' = sum(weight < 0) / n(),
                .keep = 'none'
            ) %>% 
            group_by(model) %>% 
            summarize(across(-date, ~ 100 * mean(.))) %>% 
            mutate(model = str_remove(model, 'weight_'))
        
        evaluation_stats <- evaluation_stats %>% 
            left_join(evaluation_weights, join_by(model))
    }
    
    evaluation_output <- evaluation_stats %>% 
        pivot_longer(cols = -model, names_to = 'measure') %>% 
        pivot_wider(names_from = model) %>% 
        mutate(across(where(is.numeric), ~ round(., 3)))
    
    return(evaluation_output)
}


# Optimal Parameter Choice #

# define helper function to compute objective function
compute_objective_function <- function(theta, data,
                                       objective_measure = "Expected utility",
                                       value_weighting = FALSE,
                                       allow_short_selling = TRUE) {
    processed_data <- compute_portfolio_weights(
        theta,
        data,
        value_weighting,
        allow_short_selling
    )
    
    objective_function <- evaluate_portfolio(
        processed_data,
        capm_evaluation = FALSE,
        full_evaluation = FALSE
    ) %>%
        filter(measure == objective_measure) %>%
        pull(tilt)
    
    return(-objective_function)
}

# generate initial theta and optimise 
theta <- rep(1, n_parameters)
names(theta) <- colnames(ppp_data)[str_detect(
    colnames(ppp_data), "lag")]

weights <- compute_portfolio_weights(theta, ppp_data,
                                          value_weighting = FALSE,
                                          allow_short_selling = TRUE)

evaluate_portfolio(weights)

optimal_theta <- optim(
    par = theta,
    fn = compute_objective_function,
    objective_measure = "Expected utility",
    data = ppp_data,
    value_weighting = FALSE,
    allow_short_selling = TRUE,
    method = "Nelder-Mead"
    )
optimal_theta
compute_objective_function(optimal_theta$par, ppp_data)

optimal_weights <- compute_portfolio_weights(data = ppp_data,
                                             theta = optimal_theta$par
                                             )

evaluate_portfolio(optimal_weights)

```

```{r ppp-test}
# this is kind-of working but getting some pretty weird results - perhaps to do with optim
# doesn't seem to be optimising the portfolio correctly

# Computing Portfolio Weights #

# define number of parameters by number with 'lag' in name
n_parameters <- sum(str_detect(
    colnames(ppp_data), "lag")
    )

# define arbitrary theta
theta <- rep(1.5, n_parameters)

names(theta) <- colnames(ppp_data)[str_detect(
    colnames(ppp_data), "lag")]

# computes optimal weights for a given theta 
compute_portfolio_weights <- function(theta, data,
                                      value_weighting = FALSE,
                                      allow_short_selling = TRUE){
    data %>% 
        group_by(date) %>% 
        bind_cols(
            characteristic_tilt = data %>% 
                transmute(across(contains('lag'), ~ . / n)) %>% 
                as.matrix %*% theta %>% as.numeric()
        ) %>% 
        mutate(
            # Definition of benchmark weight
            weight_benchmark = case_when(
                value_weighting == TRUE ~ relative_mktcap,
                value_weighting == FALSE ~ 1 / n
            ),
            # Parametric portfolio weights
            weight_tilt = weight_benchmark + characteristic_tilt,
            # Short-sell constraint
            weight_tilt = case_when(
                allow_short_selling == TRUE ~ weight_tilt,
                allow_short_selling == FALSE ~ pmax(0, weight_tilt)
            ),
            # Weights sum to 1
            weight_tilt = weight_tilt / sum(weight_tilt)
        ) %>% 
        ungroup()
}

# compute the weights for our arbitrary theta
weights <- compute_portfolio_weights(theta, ppp_data,
                                          value_weighting = FALSE,
                                          allow_short_selling = TRUE)

# Portfolio Performance #

# To analyse the performance we focus on the utility of a hypothetical investor with a power/CRRA utility function
power_utility <- function(r, gamma = 5){
    (1 + r)^(1 - gamma) / (1 - gamma)
}

evaluate_portfolio <- function(weights, 
                               capm_evaluation = TRUE,
                               full_evaluation = TRUE, 
                               length_year = 12){
    evaluation <- weights %>% 
        group_by(date) %>% 
        summarise(
            tilt = weighted.mean(ret_excess, weight_tilt), 
            benchmark = weighted.mean(ret_excess, weight_benchmark)
        ) %>% 
        pivot_longer(-date, 
                     values_to = 'portfolio_return', 
                     names_to = 'model'
        )
    
    evaluation_stats <- evaluation %>% 
        group_by(model) %>% 
        left_join(ff5_monthly, 
                  join_by(date == month)) %>% 
        summarise(tibble(
            "Expected utility" = mean(power_utility(portfolio_return)),
            "Average return" = 100 * mean(length_year * portfolio_return),
            "SD return" = 100 * sqrt(length_year) * sd(portfolio_return),
            "Sharpe ratio" = sqrt(length_year) * mean(portfolio_return) / sd(portfolio_return),
        )) %>% 
        mutate(model = str_remove(model, 'return_'))
    
    if (capm_evaluation) {
        evaluation_capm <- evaluation %>% 
            left_join(ff5_monthly, 
                      join_by(date == month)) %>% 
            group_by(model) %>% 
            summarise(
                'CAPM alpha' = coefficients(lm(portfolio_return ~ mkt_excess))[1],
                'Market Beta' = coefficients(lm(portfolio_return ~ mkt_excess))[2]
            )
        
        evaluation_stats <- evaluation_stats %>% 
            left_join(evaluation_capm, join_by(model))
    }
    
    if (full_evaluation) {
        evaluation_weights <- weights %>% 
            dplyr::select(date, contains('weight')) %>% 
            pivot_longer(-date, values_to = 'weight', names_to = 'model') %>% 
            group_by(model, date) %>% 
            mutate(
                'Absolute weight' = abs(weight),
                'Max. weight' = max(weight), 
                'Min. weight' = min(weight), 
                'Avg. sum of negative weights' = -sum(weight[weight < 0]),
                'Avg. fraction of negative weights' = sum(weight < 0) / n(),
                .keep = 'none'
            ) %>% 
            group_by(model) %>% 
            summarize(across(-date, ~ 100 * mean(.))) %>% 
            mutate(model = str_remove(model, 'weight_'))
        
        evaluation_stats <- evaluation_stats %>% 
            left_join(evaluation_weights, join_by(model))
    }
    
    evaluation_output <- evaluation_stats %>% 
        pivot_longer(cols = -model, names_to = 'measure') %>% 
        pivot_wider(names_from = model) %>% 
        mutate(across(where(is.numeric), ~ round(., 3)))
    
    return(evaluation_output)
}

evaluate_portfolio(weights)

# Optimal Parameter Choice #

# define helper function to compute objective 
compute_objective_function <- function(theta, data,
                                       objective_measure = "Expected utility",
                                       value_weighting = FALSE,
                                       allow_short_selling = TRUE) {
    processed_data <- compute_portfolio_weights(
        theta,
        data,
        value_weighting,
        allow_short_selling
    )
    
    objective_function <- evaluate_portfolio(
        processed_data,
        capm_evaluation = FALSE,
        full_evaluation = FALSE
    ) %>%
        filter(measure == objective_measure) %>%
        pull(tilt)
    
    return(-objective_function)
}

optimal_theta <- optim(
    par = theta,
    fn = compute_objective_function,
    objective_measure = "Expected utility",
    data = ppp_data,
    value_weighting = TRUE,
    allow_short_selling = TRUE,
    method = "Nelder-Mead"
    )

optimal_weights <- compute_portfolio_weights(theta = optimal_theta$par,
                          data = ppp_data
                          )

# optimal weights deliver extra 4% annualized return
evaluate_portfolio(optimal_weights)
# strange observation that coeff on momentum_lag is negative - investigate

# More model specifications #
evaluate_optimal_performance <- function(data, 
                                         objective_measure,
                                         value_weighting, 
                                         allow_short_selling) {
    optimal_theta <- optim(
        par = theta,
        fn = compute_objective_function,
        data = data,
        objective_measure = "Expected utility",
        value_weighting = TRUE,
        allow_short_selling = TRUE,
        method = "Nelder-Mead"
    )
    
    processed_data = compute_portfolio_weights(
        optimal_theta$par, 
        data,
        value_weighting,
        allow_short_selling
    )
    
    portfolio_evaluation = evaluate_portfolio(
        processed_data,
        capm_evaluation = TRUE,
        full_evaluation = TRUE
    )
    
    return(portfolio_evaluation) 
}

specifications <- expand_grid(
    data = list(ppp_data),
    objective_measure = "Expected utility",
    value_weighting = c(TRUE, FALSE),
    allow_short_selling = c(TRUE, FALSE)
    ) %>% 
    mutate(
        portfolio_evaluation = pmap(
            .l = list(data, objective_measure, value_weighting, allow_short_selling),
            .f = evaluate_optimal_performance
        )
    )

# Comparing results
performance_table <- specifications %>%
    dplyr::select(
        value_weighting,
        allow_short_selling,
        portfolio_evaluation
    ) %>%
    unnest(portfolio_evaluation)

performance_table %>%
    rename(
        " " = benchmark,
        Optimal = tilt
    ) %>%
    mutate(
        value_weighting = case_when(
            value_weighting == TRUE ~ "VW",
            value_weighting == FALSE ~ "EW"
        ),
        allow_short_selling = case_when(
            allow_short_selling == TRUE ~ "",
            allow_short_selling == FALSE ~ "(no s.)"
        )
    ) %>%
    pivot_wider(
        names_from = value_weighting:allow_short_selling,
        values_from = " ":Optimal,
        names_glue = "{value_weighting} {allow_short_selling} {.value} "
    ) %>%
    dplyr::select(
        measure,
        `EW    `,
        `VW    `,
        sort(contains("Optimal"))
    ) %>%
    print(n = 11)

```

